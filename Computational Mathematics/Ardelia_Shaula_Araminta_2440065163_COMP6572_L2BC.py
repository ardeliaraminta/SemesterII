# -*- coding: utf-8 -*-
"""Ardelia_Araminta_24400651633_COMP6572_L2BC

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17p-feFBLI6prspCnPRBpCY1ELhIDt7sO

FINAL EXAM COMPUTATIONAL MATHEMATICS COMP6572 L2BC 
Ardelia Shaula Araminta 2440065163
"""

import numpy as np
import math
import matplotlib.pyplot as plt

f = lambda x : 1 / (x + 5)
# exact function
exactFunc = lambda a, b : np.log(abs(b + 5)) - np.log(abs(a + 5))


# 1a Simpson's 1/3 rule
def simpson(func, a, b, panel):
    x = np.linspace(a, b, panel+1) # Because the total num of nodes is total panels + 1
    h = x[1] - x[0]
    w = np.ones(panel+1)
    for i in range(panel+1):
        # even number then append 2
        if i % 2 == 0:
            w[i] = 2.0
        # else append 4
        else:
            w[i] = 4.0
    # change first and last element to 1 
    w[0] = 1.0
    w[-1] = 1.0

    # to find total area
    area = h/3 * np.sum(w * func(x))
    return area

print(" Answer 1")
print("----------")
print(f"a. Integral result using the simpson's 1/3 rule is {simpson(f, 1, 5, 10)}")
print(f"b. The exact solution {exactFunc(1, 5)}")


# 1c relative error 
relErr = abs((simpson(f, 1, 5, 10) - exactFunc(1, 5))) / exactFunc(1, 5) * 100
print(f'c. The relative error is {relErr}%')


def f(x, y):
    return y*x**3 -1.5 *y

def int_f(x):
    return math.e**(1/4*x**4 - 3/2*x)
    
def runge_kutta5(x, y, xt, n):
    xi = []
    yi = []
    xi.append(x)
    yi.append(y)
    h = (xt - x) / n
    for i in range(0, n):
        k1 = f(x, y)
        k2 = f(x + h / 4, y + k1 * h / 4)
        k3 = f(x + h / 4, y + k1 * h / 8 + k2 * h / 8)
        k4 = f(x + h / 2, y - k2 * h / 2 + k3 * h)
        k5 = f(x + h * 3 / 4, y + k1 * h * 3 / 16 + k4 * h * 9 / 16)
        k6 = f(x + h, y - k1 * h * 3 / 7 + k2 * h * 2 / 7 + k3 * h * 12 / 7 - k4 * h * 12 / 7 + k5 * h * 8 / 7)
        y += (7 * k1 + 32 * k3 + 12 * k4 + 32 * k5 + 7 * k6) * h / 90
        xi.append(x + (i + 1) * h)
        yi.append(y)
    return xi, yi

x = 0
y = 1
xt = 5
h = 0.1
n = 6


analytical = int_f(2)
print(" Answer 2")
print("----------")
print("a. Analytical:", analytical)


def rangeKutta5(f, x, y0):
    n = np.shape(x)[0]
    y = np.zeros(n)
    dx = 0.5
    y[0] = y0
    for i in range(n-1):
        k1 = f(x[i], y[i])
        k2 = f(x[i] + (1 / 4 * dx), y[i] + (1 / 4 * k1 * dx))
        k3 = f(x[i] + (1 / 4 * dx), y[i] + (1 / 8 * k1 * dx) + (1 / 8 * k2 * dx))
        k4 = f(x[i] + (1 / 2 * dx), y[i] - (1 / 2 * k2 * dx) + (k3 * dx))
        k5 = f(x[i] + (3 / 4 * dx), y[i] + (3 / 16 * k1 * dx) + (9 / 16 * k4 * dx))
        k6 = f(x[i] + dx, y[i] - (3 / 7 * k1 * dx) + (2 / 7 * k2 * dx) + (12 / 7 * k3 * dx) - (12 / 7 * k4 * dx) + (8 / 7 * k5 * dx))
        y[i+1] = y[i] + 1 / 90 * dx * (7 * k1 + 32 * k3 + 12 * k4 + 32 * k5 + 7 * k6)
    return y


# 2a

# function given 
f = lambda x,y: y*x**3 -1.5 *y

#integral
exact = lambda x: np.exp((x**4 - 4.44 * 10-16 * x**2 - 6 * x + 0) / 4)

x = np.linspace(0, 2, 21) 
y0 = 1

# 2c
error = abs(np.linalg.norm(rangeKutta5(f, x, y0) - exact(x))) / np.linalg.norm(exact(x)) * 100
print(f"c. Relative error of fifth kutta {error}")

plt.figure(figsize = (16,9))
plt.plot(x, rangeKutta5(f, x, y0), "-o", label="rungge kutta 5", markersize=15) # 2b
plt.plot(x, exact(x), "-o", label="exact") # 2a
plt.legend()
plt.show()



def f(x):
    return (2* math.sin(x)) + (x**2/10)
    
def parabolaCalc(x0, x1, x2, n3):

    for i in range(0,n):
        y1 = f(x0)
        y2 = f(x1)
        y3 = f(x2)
        x3= (y1 * (x1**2 - x2**2) + y2 * (x2**2 - x0**2) + y3 * (x0**2 - x1**2)) / (2 * (y1 * (x1 - x2) + y2 * (x2 - x0) + y3 * (x0 - x1)))
        x0 = x1
        x1 = x2
        x2 = x3

    return x3

#integration of given function
def i_f3(x):
    return ((-2)*math.cos(x))-(x**3/30)

calc = parabolaCalc(0,1,4,3)
print(" Answer 3")
print("----------")
print("3a.Optimum value = \n",calc)
print("3a. Value of the function point = \n", f(calc))
print("3b. Objective function of gradient =\n", i_f3(calc))

# x = np.linspace(0,6,100)
# plt.plot(0, f(0), 'oy', label="x0 = 0 (starting point 1)")
# plt.plot(1, f(1), 'og', label="x1 = 1 (starting point 2)")
# plt.plot(4, f(4), 'om', label="x2 = 4 (starting point 3)")

x = np.linspace(0, 4)
funcLine = np.vectorize(f)
plt.plot(x,funcLine(x), label="f(x)")
plt.plot(0,f(0),"ro",label="x0")
plt.plot(1,f(1),"go",label="x1")
plt.plot(4,f(4),"bo",label="x2")
plt.plot(calc,f(calc),"ko",label="optimum point")

plt.title("X Values and Optimum Points")
plt.xlabel("Initial x Values")
plt.ylabel(" y Values")
plt.legend()
plt.show()

# 4

# -x + y - 2x^2 - 2xy - y^2
f = lambda x : -x[0] + x[1] - 2*x[0]**2 - 2*x[0]*x[1] - x[1]**2

# Function for gradient
# -4x - 2y - 1, -2y - 2x + 1 (first deriv of x, first deriv of y)
g = lambda x : np.array([-4*x[0] - 2*x[1] - 1, -2*x[1] - 2*x[0] + 1])

# Hessian matrix
# -4, -2
# -2, -2
h = lambda x : np.array([[-4, -2],[-2, -2]]) 


# Finding the steepest ascent
def steepest(f, g, x0):
    x = x0
    alpha = 0.01
    while 1:
        x = x + alpha * g(x)
        if np.linalg.norm(g(x)) < 1.0E-6: break
    return x


# Newton function to find optimum point
def newton(f, g, H, x0):
    x = x0
    while 1:
        x = x - np.linalg.solve(H(x), g(x))
        if np.linalg.norm(g(x)) < 1.0E-6: break
    return x


# Starting point
z = np.array([2, 3])
print(" Answer 4")
print("----------")
print(f"4a.The optimum point by the steepest ascent algorithm is {steepest(f, g, z)}")
print(f"4b.The optimum point by the Newton algorithm is {newton(f, g, h, z)}")